// indentity 함수는 인수로 무엇이 오든 그대로 반환하는 함수입니다.
// echo 명령과 비슷하게 생각할 수 있습니다.

// 제너릭이 없다면 identity 함수에 특정 타입을 주어야 합니다.
function identity1(arg: number): number {
  return arg;
}

// 또는 any 타입을 사용여 indentity 함수를 기술할 수 있습니다.
function identity2(arg: any): any {
  return arg;
}
// any를 쓰는 것은 함수의 arg가 어떤 타입이든 받을 수 있다는 점에서 제네릭이지만,
// 실제로 함수가 반환할 때 어떤 타입인지에 대한 정보는 잃게 됩니다.
// 만약 number 타입을 넘긴다고 해도 any 타입이 반환된다는 정보만 얻을 뿐입니다.

// 대신에 우리는 무엇이 반환되는지 표시하기 위해 인수의 타입을 캡처할 방법이 필요합니다.
// 여기서는 값이 아닌 타입에 적용되는 타입 변수를 사용할 수 있습니다.
function identity3<T>(arg: T): T {
  return arg;
}
// T는 유저가 준 인수의 타입을 캡처하고 (예 - number), 이 정보를 나중에 사용할 수 있게 합니다.
// 이를 통해 타입 정보를 함수의 한쪽에서 다른 한쪽으로 운반할 수 있게끔 합니다.

console.log(identity3(1));

// 이 버전의 identity 함수는 타입을 불문하고 동작하므로 제네릭이라 할 수 있습니다.
// any를 쓰는 것과는 다르게 인수와 반환 타입에 number를 사용한 첫 번째 identity 함수만큼 정확합니다. (즉, 어떤 정보도 잃지 않습니다)

// 일단 제네릭 identity 함수를 작성하고 나면, 두 가지 방법 중 하나로 호출할 수 있습니다.
// 첫 번째 방법은 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법입니다.
let output = identity3<string>("myString"); // 출력 타입은 'string'입니다.
// 여기서 우리는 함수를 호출할 때의 인수 중 하나로써 T를 string으로 명시해 주고 인수 주변에 () 대신 <>로 감싸주었습니다.

// 두 번째 방법은 아마 가장 일반적인 방법입니다.
// 여기서는 타입 인수 추론 을 사용합니다. 즉, 우리가 전달하는 인수에 따라서 컴파일러가 T의 값을 자동으로 정하게 하는 것입니다:
let output2 = identity3("myString"); //출력 타입은 'string'입니다.
